{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0ac9354b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Warning: Packages pyspark or cern.nxcals are not installed. Data retrieval from NXCALS is not possible.\n",
      " If you are on SWAN and did not expect this warning, then restart and load the 'NXCals Pro' software stack.\n",
      "No pytransport functionality\n",
      "No pytransport functionality\n"
     ]
    }
   ],
   "source": [
    "import json\n",
    "import os\n",
    "import subprocess\n",
    "\n",
    "import numpy as np\n",
    "from pathlib import Path\n",
    "import yaml\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "\n",
    "from matplotlib.ticker import MaxNLocator\n",
    "import lossmaps as lm\n",
    "import xobjects as xo\n",
    "\n",
    "import xtrack as xt\n",
    "import xcoll as xc\n",
    "\n",
    "import lossmaps as lm\n",
    "from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n",
    "\n",
    "import xarray as xr\n",
    "\n",
    "import json\n",
    "\n",
    "import xtrack as xt\n",
    "import xpart as xp\n",
    "import xobjects as xo\n",
    "\n",
    "\n",
    "import pickle \n",
    "import h5py\n",
    "import io\n",
    "import scipy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5b765dbd",
   "metadata": {},
   "outputs": [],
   "source": [
    "class LineData():\n",
    "    \n",
    "    def __init__(self, run, # 'HL' or 'Run3'\n",
    "                 line_file_name, # = 'config_sim.yaml',\n",
    "                 coll_file_name, # = 'config_sim.yaml'\n",
    "                 TCCS_name = 'tccs.5r3.b2',\n",
    "                 TCCP_name = 'tccp.4l3.b2',\n",
    "                 TARGET_name = 'target.4l3.b2',\n",
    "                 TCCS_loc_b1 =  6773.7,\n",
    "                 TCCP_loc_b1 = 6653.3,\n",
    "                 beam = 2, plane = 'V', engine = 'everest', sigma_TCCS = None, sigma_TCCP = None,\n",
    "                 job_num_part = 100000, job_num_turns = 200, \n",
    "              ):\n",
    "\n",
    "        self.run = run\n",
    "        self.line_file = f\"{os.environ.get('HOME_TWOCRYST')}/{line_file_name}\"\n",
    "        self.coll_file = f\"{os.environ.get('HOME_TWOCRYST')}/{coll_file_name}\"\n",
    "        \n",
    "        self.TCCS_name = TCCS_name\n",
    "        self.TCCP_name = TCCP_name\n",
    "        self.TARGET_name = TARGET_name\n",
    "        self.TCLA_name = 'tcla.a5l3.b2'\n",
    "        self.TCCS_loc_b1 =  6773.7\n",
    "        self.TCCP_loc_b1 = 6653.3\n",
    "        self.TCCS_loc = None\n",
    "        self.TCCP_loc = None\n",
    "        self.TARGET_loc = None\n",
    "        self.TCLA_loc = None\n",
    "        self.idx_TCCS = None\n",
    "        self.idx_TCCP = None\n",
    "        self.idx_TARGET = None\n",
    "        \n",
    "        self.beam = beam\n",
    "        self.plane = plane\n",
    "        self.job_num_part = job_num_part\n",
    "        self.job_num_turns = job_num_turns\n",
    "        self.engine = engine\n",
    "        self.plane = plane\n",
    "        self.sigma_TCCS = sigma_TCCS\n",
    "        self.sigma_TCCP = sigma_TCCP\n",
    "        self.coll_dict = None\n",
    "        self.end_s = None\n",
    "        self.line = None\n",
    "        self.norm_emittance = None\n",
    "        self.emittance = None\n",
    "        \n",
    "        if self.run == 'Run3':\n",
    "            self.norm_emittance = 3.5e-6\n",
    "        if self.run == 'HL':\n",
    "            self.norm_emittance = 2.5e-6\n",
    "        \n",
    "    def load_colldb_new(self, filename):\n",
    "        with open(filename, \"r\") as infile:\n",
    "            coll_data_string = \"\"\n",
    "            family_settings = {}\n",
    "            family_types = {}\n",
    "            onesided = {}\n",
    "            tilted = {}\n",
    "            bend = {}\n",
    "            xdim = {}\n",
    "            ydim = {}\n",
    "\n",
    "            for l_no, line in enumerate(infile):\n",
    "                if line.startswith(\"#\"):\n",
    "                    continue  # Comment\n",
    "                if len(line.strip()) == 0:\n",
    "                    continue  # Empty line\n",
    "                sline = line.split()\n",
    "                if len(sline) < 6 or sline[0].lower() == \"crystal\" or sline[0].lower() == \"target\":\n",
    "                    if sline[0].lower() == \"nsig_fam\":\n",
    "                        family_settings[sline[1]] = sline[2]\n",
    "                        family_types[sline[1]] = sline[3]\n",
    "                    elif sline[0].lower() == \"onesided\":\n",
    "                        onesided[sline[1]] = int(sline[2])\n",
    "                    elif sline[0].lower() == \"tilted\":\n",
    "                        tilted[sline[1]] = [float(sline[2]), float(sline[3])]\n",
    "                    elif sline[0].lower() == \"crystal\":\n",
    "                        bend[sline[1]] = float(sline[2])\n",
    "                        xdim[sline[1]] = float(sline[3])\n",
    "                        ydim[sline[1]] = float(sline[4])\n",
    "                    elif sline[0].lower() == \"target\":\n",
    "                        xdim[sline[1]] = float(sline[2])\n",
    "                        ydim[sline[1]] = float(sline[3])\n",
    "                    elif sline[0].lower() == \"settings\":\n",
    "                        pass  # Acknowledge and ignore this line\n",
    "                    else:\n",
    "                        raise ValueError(f\"Unknown setting {line}\")\n",
    "                else:\n",
    "                    coll_data_string += line\n",
    "\n",
    "        names = [\"name\", \"opening\", \"material\", \"length\", \"angle\", \"offset\"]\n",
    "\n",
    "        df = pd.read_csv(io.StringIO(coll_data_string), delim_whitespace=True,\n",
    "                         index_col=False, skip_blank_lines=True, names=names)\n",
    "\n",
    "        df[\"angle\"] = df[\"angle\"] \n",
    "        df[\"name\"] = df[\"name\"].str.lower() # Make the names lowercase for easy processing\n",
    "        df[\"gap\"] = df[\"opening\"].apply(lambda s: float(family_settings.get(s, s)))\n",
    "        df[\"type\"] = df[\"opening\"].apply(lambda s: family_types.get(s, \"UNKNOWN\"))\n",
    "        df[\"side\"] = df[\"name\"].apply(lambda s: onesided.get(s, 0))\n",
    "        df[\"bend\"] = df[\"name\"].apply(lambda s: bend.get(s, 0))\n",
    "        df[\"xdim\"] = df[\"name\"].apply(lambda s: xdim.get(s, 0))\n",
    "        df[\"ydim\"] = df[\"name\"].apply(lambda s: ydim.get(s, 0))\n",
    "        df[\"tilt_left\"] = df[\"name\"].apply(lambda s: np.deg2rad(tilted.get(s, [0, 0])[0]))\n",
    "        df[\"tilt_right\"] = df[\"name\"].apply(lambda s: np.deg2rad(tilted.get(s, [0, 0])[1]))\n",
    "        df.rename(columns={\"opening\": \"family\"}, inplace=True)\n",
    "        df = df.set_index(\"name\").T\n",
    "\n",
    "        # Ensure the collimators marked as one-sided or tilted are actually defined\n",
    "        defined_set = set(df.columns) # The data fram was transposed so columns are names\n",
    "        onesided_set = set(onesided.keys())\n",
    "        tilted_set = set(tilted.keys())\n",
    "        if not onesided_set.issubset(defined_set):\n",
    "            different = onesided_set - defined_set\n",
    "            raise SystemExit('One-sided collimators not defined: {}'.format(\", \".join(different)))\n",
    "        if not tilted_set.issubset(defined_set):\n",
    "            different = tilted_set - defined_set\n",
    "            raise SystemExit('Tilted collimators not defined: {}'.format(\",\".join(different)))\n",
    "        return df.T\n",
    "\n",
    "\n",
    "    def find_axis_intercepts(self, x_coords, y_coords):\n",
    "        x_intercepts = []\n",
    "        y_intercepts = []\n",
    "\n",
    "        for i in range(len(x_coords)):\n",
    "            x1, y1 = x_coords[i], y_coords[i]\n",
    "            x2, y2 = x_coords[(i + 1) % len(x_coords)], y_coords[(i + 1) % len(y_coords)]\n",
    "\n",
    "            if x1 == x2:\n",
    "            # Vertical line, no y-intercept\n",
    "                y_intercept = 0.0 if x1 == x2 == 0.0 else None\n",
    "            else:\n",
    "                slope = (y2 - y1) / (x2 - x1)\n",
    "                y_intercept = y1 - (slope * x1)\n",
    "\n",
    "            if y1 == y2:\n",
    "            # Horizontal line, no x-intercept\n",
    "                x_intercept = 0.0 if y1 == y2 == 0.0 else None\n",
    "            else:\n",
    "                slope = (x2 - x1) / (y2 - y1)\n",
    "                x_intercept = x1 - (slope * y1)\n",
    "\n",
    "            # Check if the x-intercept is within the range of x1 and x2\n",
    "            if x_intercept is not None and (x1 <= x_intercept <= x2 or x2 <= x_intercept <= x1):\n",
    "                x_intercepts.append(x_intercept)\n",
    "\n",
    "            # Check if the y-intercept is within the range of y1 and y2\n",
    "            if y_intercept is not None and (y1 <= y_intercept <= y2 or y2 <= y_intercept <= y1):\n",
    "                y_intercepts.append(y_intercept)\n",
    "\n",
    "        return x_intercepts, y_intercepts\n",
    "\n",
    "\n",
    "\n",
    "    def find_bad_offset_apertures(self, line):\n",
    "        aperture_offsets = {}\n",
    "        for name, element in line.element_dict.items():\n",
    "            if 'offset' in name and element.__class__.__name__.startswith('XYShift'):\n",
    "                aper_name = name.split('_offset')[0]\n",
    "                aperture_offsets[aper_name] = (element.dx, element.dy)\n",
    "\n",
    "        bad_apers = {}\n",
    "        for ap_name, offset in aperture_offsets.items():\n",
    "            aperture_el = line.element_dict[ap_name]\n",
    "\n",
    "            cname= aperture_el.__class__.__name__\n",
    "            ap_dict = aperture_el.to_dict()\n",
    "\n",
    "            if cname == 'LimitEllipse':\n",
    "                x_min = -ap_dict['a']\n",
    "                x_max = ap_dict['a']\n",
    "                y_min = -ap_dict['b']\n",
    "                y_max = ap_dict['b']\n",
    "            elif cname == 'LimitRect':\n",
    "                x_min = ap_dict['min_x']\n",
    "                x_max = ap_dict['max_x']\n",
    "                y_min = ap_dict['min_y']\n",
    "                y_max = ap_dict['max_y']\n",
    "            elif cname == 'LimitRectEllipse':\n",
    "                x_min = -ap_dict['max_x']\n",
    "                x_max = ap_dict['max_x']\n",
    "                y_min = -ap_dict['max_y']\n",
    "                y_max = ap_dict['max_y']\n",
    "            elif cname == 'LimitRacetrack':\n",
    "                x_min = ap_dict['min_x']\n",
    "                x_max = ap_dict['max_x']\n",
    "                y_min = ap_dict['min_y']\n",
    "                y_max = ap_dict['max_y']\n",
    "            elif cname == 'LimitPolygon':\n",
    "                x_intercepts, y_intercepts = self.find_axis_intercepts(ap_dict['x_vertices'],\n",
    "                                                                ap_dict['y_vertices'])\n",
    "                x_min = min(x_intercepts)\n",
    "                x_max = max(x_intercepts)\n",
    "                y_min = min(y_intercepts)\n",
    "                y_max = max(y_intercepts)\n",
    "\n",
    "            tolerance = 5e-3\n",
    "            \"\"\"if (x_max - offset[0] < tolerance \n",
    "                or -x_min + offset[0] < tolerance \n",
    "                or y_max - offset[1] < tolerance \n",
    "                or -y_min + offset[1] < tolerance):\"\"\"\n",
    "            if (offset[0] -x_max > tolerance \n",
    "                or  -offset[0] + x_min > tolerance \n",
    "                or  offset[1] - y_max > tolerance \n",
    "                or  -offset[1] + y_min > tolerance ):\n",
    "                    bad_apers[ap_name] = (x_min, x_max, y_min, y_max, offset[0], offset[1])\n",
    "\n",
    "        return bad_apers\n",
    "\n",
    "        \n",
    "    def load_line(self):\n",
    "        \n",
    "        #TTCS_align_angle_step = run_dict['TTCS_align_angle_step']\n",
    "\n",
    "        #mode = run_dict['mode']\n",
    "        #print('\\nMode: ', mode, '\\n')\n",
    "\n",
    "        print('Input files:\\n', self.line_file, '\\n', self.coll_file, '\\n')\n",
    "\n",
    "        if self.coll_file.endswith('.yaml'):\n",
    "            with open(self.coll_file, 'r') as stream:\n",
    "                coll_dict = yaml.safe_load(stream)['collimators'][f'b{self.beam}']\n",
    "        if self.coll_file.endswith('.data'):\n",
    "            coll_dict = self.load_colldb_new(self.coll_file).to_dict('index')\n",
    "\n",
    "        context = xo.ContextCpu(omp_num_threads='auto')\n",
    "        self.coll_dict = coll_dict\n",
    "        \n",
    "        # Load Line in Xtrack\n",
    "        line = xt.Line.from_json(self.line_file)\n",
    "        self.end_s = line.get_length()\n",
    "        \n",
    "        self.TCCS_loc = self.end_s - self.TCCS_loc_b1 #6775\n",
    "        self.TCCP_loc = self.end_s - self.TCCP_loc_b1 #6655\n",
    "        self.TARGET_loc = self.end_s - (self.TCCP_loc_b1 + coll_dict[self.TCCP_name][\"length\"]/2 + coll_dict[self.TARGET_name][\"length\"]/2)\n",
    "        self.TCLA_loc = line.get_s_position()[line.element_names.index(self.TCLA_name)]\n",
    "\n",
    "        line.insert_element(at_s=self.TCCS_loc, element=xt.Marker(), name=self.TCCS_name)\n",
    "        line.insert_element(at_s=self.TCCS_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name=self.TCCS_name+'_aper')\n",
    "        line.insert_element(at_s=self.TARGET_loc, element=xt.Marker(), name=self.TARGET_name)\n",
    "        line.insert_element(at_s=self.TARGET_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name=self.TARGET_name+'_aper')\n",
    "        line.insert_element(at_s=self.TCCP_loc, element=xt.Marker(), name=self.TCCP_name)\n",
    "        line.insert_element(at_s=self.TCCP_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name=self.TCCP_name+'_aper')\n",
    "\n",
    "        TCCS_monitor = xt.ParticlesMonitor(num_particles=self.job_num_part, start_at_turn=0, stop_at_turn=self.job_num_turns)\n",
    "        TARGET_monitor = xt.ParticlesMonitor(num_particles=self.job_num_part, start_at_turn=0, stop_at_turn=self.job_num_turns)\n",
    "        dx = 1e-11\n",
    "        line.insert_element(at_s = self.TCCS_loc - coll_dict[self.TCCS_name][\"length\"]/2 - dx, element=TCCS_monitor, name='TCCS_monitor')\n",
    "        line.insert_element(at_s = self.TARGET_loc - coll_dict[self.TARGET_name][\"length\"]/2 - dx, element=TARGET_monitor, name='TARGET_monitor')\n",
    "\n",
    "\n",
    "        \"\"\" bad_aper = self.find_bad_offset_apertures(line)\n",
    "        print('Bad apertures : ', bad_aper)\n",
    "        print('Replace bad apertures with Marker')\n",
    "        for name in bad_aper.keys():\n",
    "            line.element_dict[name] = xt.Marker()\n",
    "            print(name, line.get_s_position(name), line.element_dict[name])\n",
    "\n",
    "        # Aperture model check\n",
    "        print('\\nAperture model check on imported model:')\n",
    "        df_imported = line.check_aperture()\n",
    "        assert not np.any(df_imported.has_aperture_problem)\n",
    "\n",
    "\n",
    "        # Initialise collmanager\n",
    "        if self.coll_file.endswith('.yaml'):\n",
    "            coll_manager = xc.CollimatorManager.from_yaml(self.coll_file, line=line, beam=self.beam, _context=context, ignore_crystals=False)\n",
    "        elif self.coll_file.endswith('.data'):\n",
    "            coll_manager = xc.CollimatorManager.from_SixTrack(self.coll_file, line=line, _context=context, ignore_crystals=False, nemitt_x = 2.5e-6,  nemitt_y = 2.5e-6)\n",
    "            # switch on cavities\n",
    "            speed = line.particle_ref._xobject.beta0[0]*scipy.constants.c\n",
    "            harmonic_number = 35640\n",
    "            voltage = 12e6/len(line.get_elements_of_type(xt.Cavity)[1])\n",
    "            frequency = harmonic_number * speed /line.get_length()\n",
    "            for side in ['l', 'r']:\n",
    "                for cell in ['a','b','c','d']:\n",
    "                    line[f'acsca.{cell}5{side}4.b2'].voltage = voltage\n",
    "                    line[f'acsca.{cell}5{side}4.b2'].frequency = frequency\n",
    "\n",
    "        # Install collimators into line\n",
    "        if self.engine == 'everest':\n",
    "            coll_names = coll_manager.collimator_names\n",
    "            black_absorbers = [self.TARGET_name,]\n",
    "\n",
    "            everest_colls = [name for name in coll_names if name not in black_absorbers]\n",
    "            coll_manager.install_everest_collimators(names=everest_colls,verbose=True)\n",
    "            coll_manager.install_black_absorbers(names = black_absorbers, verbose=True)\n",
    "        else:\n",
    "            raise ValueError(f\"Unknown scattering engine {self.engine}!\")\n",
    "        \n",
    "        # Aperture model check\n",
    "        print('\\nAperture model check after introducing collimators:')\n",
    "        df_with_coll = line.check_aperture()\n",
    "        assert not np.any(df_with_coll.has_aperture_problem)\n",
    "      \n",
    "        # Build the tracker\n",
    "        coll_manager.build_tracker()\n",
    "\n",
    "        # Set the collimator openings based on the colldb,\n",
    "        # or manually override with the option gaps={collname: gap}\n",
    "        coll_manager.set_openings()\n",
    "\n",
    "        # Aperture model check\n",
    "        print('\\nAperture model check after introducing collimators:')\n",
    "        df_with_coll = line.check_aperture()\n",
    "        assert not np.any(df_with_coll.has_aperture_problem)\"\"\"\n",
    "        \n",
    "        self.line = line         \n",
    "        return\n",
    "    \n",
    "    def compute_sigma_element(self, element_name):\n",
    "        if self.line is None:\n",
    "            self.load_line()\n",
    "        twiss = self.line.twiss()\n",
    "        beta_y_optics = twiss['bety', element_name]\n",
    "        alfa_y_optics = twiss['alfy', element_name]\n",
    "        if self.emittance is None:\n",
    "            self.emittance_phy = self.norm_emittance/(self.line.particle_ref._xobject.beta0[0]*self.line.particle_ref._xobject.gamma0[0])\n",
    "        sigma = np.sqrt(self.emittance_phy*beta_y_optics)\n",
    "        return(sigma)\n",
    "    \n",
    "    def compute_crystals(self):\n",
    "        if self.line is None:\n",
    "            self.load_line()\n",
    "        self.idx_TCCS = self.line.element_names.index(self.TCCS_name)\n",
    "        self.idx_TARGET = self.line.element_names.index(self.TARGET_name)\n",
    "        self.idx_TCCP = self.line.element_names.index(self.TCCP_name)\n",
    "        \n",
    "        \"\"\"print(f\"\\n\\nParticleAnalysis(element_type=\\'crystal\\', n_sigma={self.coll_dict[self.TCCS_name]['gap']}, length={self.coll_dict[self.TCCS_name]['length']}, ydim={self.coll_dict[self.TCCS_name]['xdim']}, xdim={self.coll_dict[self.TCCS_name]['ydim']}, bend={self.coll_dict[self.TCCS_name]['bend']}, align_angle={self.line.elements[self.idx_TCCS].align_angle}, jaw_L={self.line.elements[self.idx_TCCS].jaw_L}), line_idx={self.idx_TCCS}\")\n",
    "        print(f\"ParticleAnalysis(element_type=\\'target\\', n_sigma={self.coll_dict[self.TARGET_name]['gap']}, length={self.coll_dict[self.TARGET_name]['length']}, ydim={self.coll_dict[self.TARGET_name]['xdim']}, xdim={self.coll_dict[self.TARGET_name]['ydim']}, jaw_L={self.line.elements[self.idx_TARGET].jaw_L}), line_idx={self.idx_TARGET}\")\n",
    "                print(f\"ParticleAnalysis(element_type=\\'crystal\\', n_sigma={self.coll_dict[self.TCCP_name]['gap']}, length={self.coll_dict[self.TCCP_name]['length']}, ydim={self.coll_dict[self.TCCP_name]['xdim']}, xdim={self.coll_dict[self.TCCP_name]['ydim']}, bend={self.coll_dict[self.TCCP_name]['bend']}, jaw_L={self.line.elements[self.idx_TCCP].jaw_L}), line_idx={self.idx_TCCP}\")\n",
    "            \"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6c818725",
   "metadata": {},
   "outputs": [],
   "source": [
    "line_test0 = LineData(run='HL', line_file_name = 'input_files/HL_IR7_rematched/b4_sequence_patched.json', \n",
    "                     coll_file_name = 'input_files/CollDB_HL_tight_b4.data')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "19d73283",
   "metadata": {},
   "outputs": [],
   "source": [
    "line_test1 = LineData(run='HL', line_file_name = 'input_files/HL_IR7_IR3_rematched/b4_sequence_patched.json', \n",
    "                     coll_file_name = 'input_files/CollDB_HL_tight_b4.data')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c2fca95",
   "metadata": {},
   "outputs": [],
   "source": [
    "line_test2 = LineData(run='Run3', line_file_name = 'input_files/flat_top_b2.json', \n",
    "                     coll_file_name = 'input_files/flat_top.yaml')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "63330ab4",
   "metadata": {},
   "outputs": [],
   "source": [
    "line_test0.compute_crystals()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34508845",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
