{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b41b6e6e",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No pytransport functionality\n",
      "No pytransport functionality\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import json\n",
    "import yaml\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "\n",
    "from matplotlib.ticker import MaxNLocator\n",
    "\n",
    "import xobjects as xo\n",
    "import xtrack as xt\n",
    "import xpart as xp\n",
    "\n",
    "import pymadx\n",
    "from xcoll_plotting import plot_functions as xcp\n",
    "import scipy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "cbdeca56",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# FUNCTION TO FIND BAD APERTURES IN LINE THAT PREVENT CLOSED ORBIT SEARCH\n",
    "\n",
    "def find_axis_intercepts(x_coords, y_coords):\n",
    "    x_intercepts = []\n",
    "    y_intercepts = []\n",
    "\n",
    "    for i in range(len(x_coords)):\n",
    "        x1, y1 = x_coords[i], y_coords[i]\n",
    "        x2, y2 = x_coords[(i + 1) % len(x_coords)], y_coords[(i + 1) % len(y_coords)]\n",
    "\n",
    "        if x1 == x2:\n",
    "        # Vertical line, no y-intercept\n",
    "            y_intercept = 0.0 if x1 == x2 == 0.0 else None\n",
    "        else:\n",
    "            slope = (y2 - y1) / (x2 - x1)\n",
    "            y_intercept = y1 - (slope * x1)\n",
    "\n",
    "        if y1 == y2:\n",
    "        # Horizontal line, no x-intercept\n",
    "            x_intercept = 0.0 if y1 == y2 == 0.0 else None\n",
    "        else:\n",
    "            slope = (x2 - x1) / (y2 - y1)\n",
    "            x_intercept = x1 - (slope * y1)\n",
    "\n",
    "        # Check if the x-intercept is within the range of x1 and x2\n",
    "        if x_intercept is not None and (x1 <= x_intercept <= x2 or x2 <= x_intercept <= x1):\n",
    "            x_intercepts.append(x_intercept)\n",
    "\n",
    "        # Check if the y-intercept is within the range of y1 and y2\n",
    "        if y_intercept is not None and (y1 <= y_intercept <= y2 or y2 <= y_intercept <= y1):\n",
    "            y_intercepts.append(y_intercept)\n",
    "\n",
    "    return x_intercepts, y_intercepts\n",
    "\n",
    "\n",
    "\n",
    "def find_bad_offset_apertures(line):\n",
    "    aperture_offsets = {}\n",
    "    for name, element in line.element_dict.items():\n",
    "        if 'offset' in name and element.__class__.__name__.startswith('XYShift'):\n",
    "            aper_name = name.split('_offset')[0]\n",
    "            aperture_offsets[aper_name] = (element.dx, element.dy)\n",
    "\n",
    "    bad_apers = {}\n",
    "    for ap_name, offset in aperture_offsets.items():\n",
    "        aperture_el = line.element_dict[ap_name]\n",
    "\n",
    "        cname= aperture_el.__class__.__name__\n",
    "        ap_dict = aperture_el.to_dict()\n",
    "\n",
    "        if cname == 'LimitEllipse':\n",
    "            x_min = -ap_dict['a']\n",
    "            x_max = ap_dict['a']\n",
    "            y_min = -ap_dict['b']\n",
    "            y_max = ap_dict['b']\n",
    "        elif cname == 'LimitRect':\n",
    "            x_min = ap_dict['min_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = ap_dict['min_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitRectEllipse':\n",
    "            x_min = -ap_dict['max_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = -ap_dict['max_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitRacetrack':\n",
    "            x_min = ap_dict['min_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = ap_dict['min_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitPolygon':\n",
    "            x_intercepts, y_intercepts = find_axis_intercepts(ap_dict['x_vertices'],\n",
    "                                                            ap_dict['y_vertices'])\n",
    "            x_min = min(x_intercepts)\n",
    "            x_max = max(x_intercepts)\n",
    "            y_min = min(y_intercepts)\n",
    "            y_max = max(y_intercepts)\n",
    "\n",
    "        tolerance = 5e-3\n",
    "        \"\"\"if (x_max - offset[0] < tolerance \n",
    "            or -x_min + offset[0] < tolerance \n",
    "            or y_max - offset[1] < tolerance \n",
    "            or -y_min + offset[1] < tolerance):\"\"\"\n",
    "        if (offset[0] -x_max > tolerance \n",
    "            or  -offset[0] + x_min > tolerance \n",
    "            or  offset[1] - y_max > tolerance \n",
    "            or  -offset[1] + y_min > tolerance ):\n",
    "                bad_apers[ap_name] = (x_min, x_max, y_min, y_max, offset[0], offset[1])\n",
    "\n",
    "    return bad_apers\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "1ae5953d",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# SPECIFIC CONVERSION FUNCTIONS \n",
    "\n",
    "def change_coordinates_to_b1(df, end_s):\n",
    "    if 's' in df.columns:\n",
    "        df['s'] = end_s - df['s']\n",
    "    else:\n",
    "        new_index = [end_s - i for i in df.index.values]\n",
    "        df.index = new_index \n",
    "    return df\n",
    "\n",
    "\n",
    "def reset_coord_cry_tracking(df, twiss, end_s, TCCS_loc, TCCS_name):\n",
    "    df['s'] = np.where(df['s'] <=  end_s-TCCS_loc, end_s-TCCS_loc-df['s'], 2*end_s-TCCS_loc-df['s'])\n",
    "    names = twiss.to_pandas().name.to_numpy()\n",
    "    idx = np.where(names == TCCS_name)[0][0]\n",
    "    names = np.roll(names, -idx)\n",
    "    df['name'] = names\n",
    "    df = df.sort_values(by=\"s\")\n",
    "    return df\n",
    "\n",
    "\n",
    "def extract_channelled(df, end_s, TCCS_loc, TCLA_loc):\n",
    "    df = df.loc[(df['s']<end_s-TCCS_loc) & (df['s']>end_s-TCLA_loc)]\n",
    "    return df\n",
    "\n",
    "\n",
    "def filter_aperture_rotations(df, line):    \n",
    "    aperture_offsets = []\n",
    "    for name, element in line.element_dict.items():\n",
    "        if '_tilt_entry' in name and element.__class__.__name__.startswith('SRotation'):\n",
    "            aper_name = name.split('_tilt')[0]\n",
    "            aperture_offsets.append(aper_name)#[aper_name] = (element.s)\n",
    "\n",
    "    return df[~df['name'].str.contains('|'.join(aperture_offsets), case=False)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "89e4a135",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# STANDARD CONVERSION FUNCTIONS\n",
    "\n",
    "def _norm_to_geom_emittance(norm_emittance, E0, E):\n",
    "    betagamma = _calc_betagamma(E0, E)\n",
    "    return norm_emittance / betagamma\n",
    "\n",
    "def _calc_betagamma(E0, E):\n",
    "    gamma = float(E)/E0\n",
    "    beta = np.sqrt(1.-(1./gamma)**2)\n",
    "    return beta*gamma\n",
    "\n",
    "def rad_to_deg(n):\n",
    "    return n*180/np.pi\n",
    "\n",
    "def convert_m_to_mm(val):\n",
    "    return val / 1e-3\n",
    "\n",
    "def convert_mm_to_m(val):\n",
    "    return val * 1e-3\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "1f9baf90",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# LOAD COLLIMATORS FUNCTIONS\n",
    "\n",
    "def add_collimator_halfgap(coll_df, nemitt_x, nemitt_y, \n",
    "                           reference_mass, reference_energy):\n",
    "        \n",
    "    # Calculate the geometric emittances first\n",
    "    emit_geom_x = _norm_to_geom_emittance(nemitt_x, reference_mass, reference_energy)\n",
    "    emit_geom_y = _norm_to_geom_emittance(nemitt_y, reference_mass, reference_energy)\n",
    "\n",
    "    openings = []\n",
    "    sigmas_x = []\n",
    "    sigmas_y = []\n",
    "    for name, parameters in coll_df.iterrows():\n",
    "        betx = parameters[\"betx\"]\n",
    "        bety = parameters[\"bety\"]\n",
    "        if 'gap' in parameters.index:\n",
    "            nsigma = parameters[\"gap\"]\n",
    "        elif 'nsigma' in parameters.index:\n",
    "            nsigma = parameters[\"nsigma\"]\n",
    "        angle  = parameters[\"angle\"]\n",
    "\n",
    "        sigma_x = np.sqrt(betx * emit_geom_x)\n",
    "        sigma_y = np.sqrt(bety * emit_geom_y)\n",
    "\n",
    "        a = nsigma * sigma_x\n",
    "        b = nsigma * sigma_y\n",
    "\n",
    "        x = a * np.cos(angle)\n",
    "        y = b * np.sin(angle)\n",
    "\n",
    "        sigmas_x.append(sigma_x)\n",
    "        sigmas_y.append(sigma_y)\n",
    "        openings.append(np.sqrt(x**2 + y**2))\n",
    "\n",
    "    coll_df['sigma_x'] = sigmas_x\n",
    "    coll_df['sigma_y'] = sigmas_y\n",
    "    coll_df['opening'] = openings\n",
    "    \n",
    "\n",
    "\n",
    "def load_coll(filename, optics_df, reference_mass, reference_energy,\n",
    "                          nemitt_x = 3.5e-6, nemitt_y = 3.5e-6, beam = 2):\n",
    "    \n",
    "    if filename.endswith('.yaml'):\n",
    "        # load collimators form yaml file as pandas\n",
    "        with open(filename, 'r') as file:\n",
    "            collimators = yaml.safe_load(file)   \n",
    "        coll_dict  = collimators['collimators'][f'b{beam}']\n",
    "        df = pd.DataFrame.from_dict(coll_dict, orient=\"index\")\n",
    "    else:\n",
    "        df  = xcp.load_colldb_new(filename)\n",
    "    df = df.rename_axis('name').reset_index()\n",
    "    coll_list = df['name'].to_list()\n",
    "    \n",
    "    # merge it with dataframe from twiss\n",
    "    df_col_twiss = optics_df[optics_df['name'].isin(coll_list)]\n",
    "    df_coll_tot = pd.merge(df, df_col_twiss, on=\"name\")\n",
    "    \n",
    "    add_collimator_halfgap(df_coll_tot, nemitt_x, nemitt_y, \n",
    "                           reference_mass, reference_energy)\n",
    "    return df_coll_tot\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "30b641ea",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# PLOT COLLIMATORS \n",
    "\n",
    "def plot_collimators(coll_data, ax, plane, df_twiss, end_s, df_chann, plot_offplane_coll = True):\n",
    "\n",
    "    coll_data = change_coordinates_to_b1(coll_data, end_s)\n",
    "\n",
    "\n",
    "    hors = (coll_data['angle'] <  rad_to_deg(0.1)) | (coll_data['angle'] >  rad_to_deg(6.1))\n",
    "    vers = (coll_data['angle'] >  rad_to_deg(1.5)) & (coll_data['angle'] <  rad_to_deg(1.6))\n",
    "\n",
    "\n",
    "    collimators_hor = coll_data.loc[hors]\n",
    "    collimators_ver = coll_data.loc[vers]\n",
    "    collimators_ske = coll_data.loc[(~hors) & (~vers)]\n",
    "    \n",
    "\n",
    "\n",
    "    if plane == 'h':\n",
    "        in_plane_collimators = collimators_hor\n",
    "        off_plane_collimators = pd.concat([collimators_ver, collimators_ske])\n",
    "    elif plane == 'v':\n",
    "        in_plane_collimators = collimators_ver\n",
    "        off_plane_collimators = pd.concat([collimators_hor, collimators_ske])\n",
    "    else:\n",
    "        raise Exception(f'Cannot use plane \"{[plane]}\", '\n",
    "                        'allowed planes for aperture plot are h and v')\n",
    "\n",
    "    coll_lw = 1\n",
    "\n",
    "    for index, coll in in_plane_collimators.iterrows():\n",
    "        s_centre = coll[\"s\"]\n",
    "        hgap    = coll[\"opening\"]\n",
    "\n",
    "        if(coll['name'] == TCCS_name):\n",
    "            s_centre = float(df_twiss[df_twiss[\"name\"] == TCCS_name]['s'])\n",
    "            hgap = df_twiss[df_twiss['s'] == s_centre]['n_sigma_y'].iloc[0]\n",
    "        elif(coll['name'] == TCCP_name):\n",
    "            s_centre = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['s'])\n",
    "            hgap = df_chann[df_chann['s'] == s_centre]['y'].iloc[0]\n",
    "        elif(coll['name'] == TARGET_name):\n",
    "            continue\n",
    "\n",
    "\n",
    "        orbit = coll['x'] if plane=='h' else coll['y']\n",
    "        sstart  = s_centre - coll[\"length\"]/2\n",
    "        send    = s_centre + coll[\"length\"]/2\n",
    "        w       = send-sstart\n",
    "        top_lim = plt.ylim()[1]*2\n",
    "        bot_lim = plt.ylim()[0]*2\n",
    "        h       = top_lim - hgap\n",
    "        \n",
    "        \n",
    "        if coll['side'] == 'left':\n",
    "            color = 'r' if not pd.isna(coll['crystal']) else 'k'\n",
    "            jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                        fc=color, ec=color, lw=coll_lw, zorder=10)\n",
    "            ax.add_patch(jaw)\n",
    "\n",
    "        elif coll['side'] == 'right': \n",
    "            color = 'r' if not pd.isna(coll['crystal']) else 'k'      \n",
    "            jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0, \n",
    "                                        fc=color, ec=color, lw=coll_lw,  zorder=10)\n",
    "            ax.add_patch(jaw)\n",
    "            \n",
    "        else:\n",
    "            upper_jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                          fc=\"k\", ec=\"k\", lw=coll_lw, zorder=10)\n",
    "            lower_jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0, \n",
    "                                          fc=\"k\", ec=\"k\", lw=coll_lw,  zorder=10)\n",
    "            ax.add_patch(upper_jaw)\n",
    "            ax.add_patch(lower_jaw)\n",
    "\n",
    "\n",
    "    if plot_offplane_coll:\n",
    "        for index, coll in off_plane_collimators.iterrows():\n",
    "            s_centre = coll[\"s\"]\n",
    "            sstart  = s_centre - coll[\"length\"]/2\n",
    "            send    = s_centre + coll[\"length\"]/2\n",
    "            orbit = coll['x'] if plane=='h' else coll['y']\n",
    "\n",
    "            alpha = 1\n",
    "            color = 'slategray'\n",
    "            edcgecolor = 'slategray'\n",
    "\n",
    "            coll_angle = coll['angle']\n",
    "            coll_opening = coll['opening']\n",
    "            if plane == 'h':\n",
    "                hgap = (coll_opening / np.abs(np.cos(coll_angle)) \n",
    "                        if not np.isclose(np.cos(coll_angle), 0) else np.inf)\n",
    "            elif plane == 'v':\n",
    "                hgap = (coll_opening/ np.abs(np.sin(coll_angle)) \n",
    "                        if not np.isclose(np.sin(coll_angle), 0) else np.inf)\n",
    "\n",
    "            if np.isnan(hgap) or hgap > 0.900:\n",
    "                hgap = 0 # Closed bars for non-cut collimators\n",
    "                alpha = 1\n",
    "                color = 'lightgray'\n",
    "                edcgecolor = 'lightgray'\n",
    "\n",
    "            w       = send-sstart\n",
    "            top_lim = plt.ylim()[1]*2\n",
    "            bot_lim = plt.ylim()[0]*2\n",
    "            h       = top_lim - hgap\n",
    "            upper_jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                            fc=color, ec=edcgecolor, alpha=alpha, \n",
    "                                            lw=coll_lw, zorder=0)\n",
    "            \n",
    "            lower_jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0,\n",
    "                                            fc=color, ec=edcgecolor, alpha=alpha, \n",
    "                                            lw=coll_lw, zorder=0)\n",
    "\n",
    "            ax.add_patch(upper_jaw)\n",
    "            ax.add_patch(lower_jaw)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "b2685127",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# PLOT \n",
    "\n",
    "def plot_IR3(plot_axis, df_ref, df_chann, df_chann_upper, df_chann_lower, df_apertures, end_s, df_coll=None, s_start=6300, s_stop=7100):\n",
    "    \n",
    "    plot_axis.plot(df_ref[\"s\"],df_ref[\"y\"],color=\"orange\")\n",
    "\n",
    "\n",
    "    plot_axis.plot(df_ref[\"s\"],df_ref[\"n_sigma_y\"], color='C1')\n",
    "    plot_axis.plot(df_ref[\"s\"],-df_ref[\"n_sigma_y\"], color='C1')\n",
    "    plot_axis.fill_between(df_ref[\"s\"], df_ref[\"n_sigma_y\"], -df_ref[\"n_sigma_y\"], color='C1', alpha=0.3)\n",
    "\n",
    "\n",
    "    plot_axis.plot(df_chann[\"s\"],df_chann[\"y\"], color='darkblue')\n",
    "    plot_axis.plot(df_chann_upper[\"s\"],df_chann_upper[\"y\"], color='blue')\n",
    "    plot_axis.plot(df_chann_lower[\"s\"],df_chann_lower[\"y\"], color='blue')\n",
    "    plot_axis.fill_between(df_chann[\"s\"], df_chann_upper[\"y\"],df_chann_lower[\"y\"], color='blue', alpha=0.3)\n",
    "\n",
    "\n",
    "    plot_axis.set_xlabel('s [m]',  fontsize=17)\n",
    "    plot_axis.set_xlim(s_start, s_stop)\n",
    "    plot_axis.set_ylim(-0.03, 0.03)\n",
    "    plot_axis.set_ylabel('y [m]',  fontsize=17)\n",
    "    plot_axis.grid(linestyle=':')\n",
    "    #plot_axis.set_yticks(ticks=plt.yticks()[0], labels=[f\"{x*1e3:.{0}f}\" for x in plt.yticks()[0]])\n",
    "    \n",
    "    \n",
    "    plot_axis.tick_params(axis='both', which='major', labelsize=15)\n",
    "    \n",
    "    plot_axis.text(end_s - TCCS_loc, max(plot_axis.get_yticks())+0.0008, \"TCCS\", horizontalalignment='center', fontsize=17)\n",
    "    plot_axis.text(end_s - TCCP_loc, max(plot_axis.get_yticks())+0.0008, \"TCCP\", horizontalalignment='center', fontsize=17)\n",
    "    plot_axis.text(end_s - TCLA_loc, max(plot_axis.get_yticks())+0.0008, \"TCLA\", horizontalalignment='center', fontsize=17)\n",
    "\n",
    "    # convert, xcp function handles dataframe in m\n",
    "    xcp.plot_apertures(df_apertures[['xmin', 'xmax', 'ymin', 'ymax']].apply(lambda x: convert_mm_to_m(x)), plot_axis, \"v\")\n",
    "    \n",
    "    if df_coll is not None:\n",
    "        plot_collimators(df_coll, plot_axis, \"v\", df_ref, df_chann, end_s, plot_offplane_coll = True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de00d0a3",
   "metadata": {},
   "source": [
    "# Load and Set-up"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "4865a7ba",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "## Choose a context\n",
    "context = xo.ContextCpu()         # For CPU"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "57e88f54",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "def calc_nsigma_TCCP(df_twiss, df_chann, emittance_phy):\n",
    "\n",
    "    s_centre = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['s'])\n",
    "    hgap =  df_chann[df_chann['s'] == s_centre]['y'].iloc[0]  - df_twiss[df_twiss['s'] == s_centre]['y'].iloc[0]\n",
    "    beta_y = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['bety'])\n",
    "    sigma =  np.sqrt(emittance_phy*beta_y)\n",
    "\n",
    "    #five_sig_gap  = df_twiss[df_twiss['s'] == s_centre]['n_sigma_y'].iloc[0] - df_twiss[df_twiss['s'] == s_centre]['y'].iloc[0]\n",
    "    #print('check: ', five_sig_gap/sigma)\n",
    "    \n",
    "    return hgap/sigma, hgap \n",
    "\n",
    "\n",
    "def run_cry_tracking(line_name, normalized_emittance, n_sigma, **kwargs):    \n",
    "\n",
    "    # load line\n",
    "    line = xt.Line.from_json(line_name)\n",
    "    end_s = line.get_length()\n",
    "\n",
    "    # insert twocryst setup\n",
    "    TCCS_name = 'tccs.5r3.b2'\n",
    "    TCCP_name = 'tccp.4l3.b2'\n",
    "    TARGET_name = 'target.4l3.b2'\n",
    "    TCLA_name = 'tcla.a5l3.b2'\n",
    "\n",
    "    TCCS_loc = end_s - 6773.7 #6775\n",
    "    TCCP_loc = end_s - 6653.3 #6655\n",
    "    TARGET_loc = end_s - (6653.3 + 0.07/2 +0.005/2)\n",
    "    TCLA_loc = line.get_s_position(TCLA_name)\n",
    "\n",
    "    line.insert_element(at_s=TCCS_loc, element=xt.Marker(), name = TCCS_name)\n",
    "    line.insert_element(at_s=TCCS_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TCCS_name + '_aper')\n",
    "    line.insert_element(at_s=TCCP_loc, element=xt.Marker(), name=TCCP_name)\n",
    "    line.insert_element(at_s=TCCP_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TCCP_name + '_aper')\n",
    "    line.insert_element(at_s=TARGET_loc, element=xt.Marker(), name=TARGET_name)\n",
    "    line.insert_element(at_s=TARGET_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TARGET_name + '_aper')\n",
    "\n",
    "    bad_aper = find_bad_offset_apertures(line)\n",
    "    print('Bad apertures : ', bad_aper)\n",
    "    print('Replace bad apertures with Marker')\n",
    "    for name in bad_aper.keys():\n",
    "        line.element_dict[name] = xt.Marker()\n",
    "        print(name, line.get_s_position(name), line.element_dict[name])\n",
    "\n",
    "    line.build_tracker(_context=context)\n",
    "\n",
    "    # compute critical angle\n",
    "    beta_rel = line.particle_ref._xobject.beta0[0]\n",
    "    gamma = line.particle_ref._xobject.gamma0[0]\n",
    "    energy = line.particle_ref._xobject.p0c[0]\n",
    "\n",
    "    bend = 80.00\n",
    "\n",
    "    emittance_phy = normalized_emittance/(beta_rel*gamma)\n",
    "    pot_well_Si = 21\n",
    "    energy_well_Si = 5.7e9 / 1e-2 #eV/m\n",
    "    Rcrit = energy/energy_well_Si\n",
    "    xp_crit0 = np.sqrt(2*pot_well_Si/(energy*beta_rel))\n",
    "    critical_angle = xp_crit0*(1-Rcrit/bend)\n",
    "\n",
    "    #switch on cavities\n",
    "    speed = beta_rel*scipy.constants.c\n",
    "    harmonic_number = 35640\n",
    "    voltage = 12e6/len(line.get_elements_of_type(xt.Cavity)[1])\n",
    "    frequency = harmonic_number * speed /line.get_length()\n",
    "    for side in ['l', 'r']:\n",
    "        for cell in ['a','b','c','d']:\n",
    "            line[f'acsca.{cell}5{side}4.b2'].voltage = voltage\n",
    "            line[f'acsca.{cell}5{side}4.b2'].frequency = frequency\n",
    "\n",
    "    # set up particles\n",
    "    twiss = line.twiss()\n",
    "    beta_y_cry1  = twiss['bety', TCCS_name]\n",
    "    alpha_y_cry1 = twiss['alfy', TCCS_name]\n",
    "\n",
    "    cry_part_chann = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6,\n",
    "                            _context=context)\n",
    "\n",
    "\n",
    "    cry_part_chann_upper = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6+critical_angle,\n",
    "                            _context=context)\n",
    "\n",
    "\n",
    "    cry_part_chann_lower = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6-critical_angle,\n",
    "                            _context=context)\n",
    "\n",
    "    # track particles\n",
    "    df_ref = change_coordinates_to_b1(twiss.to_pandas(), end_s)\n",
    "    df_ref = filter_aperture_rotations(df_ref, line)\n",
    "    df_ref['n_sigma_y'] = n_sigma*np.sqrt(emittance_phy*df_ref['bety'])\n",
    "\n",
    "    line.track(cry_part_chann, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part = filter_aperture_rotations(df_chann_part, line)\n",
    "    df_chann_part = extract_channelled(df_chann_part,end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    line.track(cry_part_chann_upper, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part_upper = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part_upper = filter_aperture_rotations(df_chann_part_upper, line)\n",
    "    df_chann_part_upper = extract_channelled(df_chann_part_upper, end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    line.track(cry_part_chann_lower, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part_lower = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part_lower = filter_aperture_rotations(df_chann_part_lower, line)\n",
    "    df_chann_part_lower = extract_channelled(df_chann_part_lower, end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    upper_sig, upper_m = calc_nsigma_TCCP(df_ref, df_chann_part_upper, emittance_phy, TCCP_name)\n",
    "    central_sig, central_m =  calc_nsigma_TCCP(df_ref, df_chann_part, emittance_phy, TCCP_name)\n",
    "    lower_sig, lower_m =  calc_nsigma_TCCP(df_ref, df_chann_part_lower, emittance_phy)\n",
    "\n",
    "    print(f'\\nEnergy: {energy/1e9:.2f} GeV \\t TCCS sigma setting: {n_sigma}' )\n",
    "    print(f'\\nUpper: {upper_sig:.2f} sigma, {upper_m*1e3:.2f} mm')\n",
    "    print(f'Central: {central_sig:.2f} sigma, {central_m*1e3:.2f} mm')\n",
    "    print(f'Lower: {lower_sig:.2f} sigma, {lower_m*1e3:.2f} mm')\n",
    "    print(f'\\nDimesion of the 5 sigma channelled spot (upper-lower): {(upper_m-lower_m)*1e3:.2f} mm   \\tCrystal height: 2 mm')\n",
    "    print(f'Center the spot in the crystal: [{central_m*1e3-1:.2f},{central_m*1e3+1:.2f}] mm')\n",
    "    beta_y = float(df_ref[df_ref[\"name\"] == TCCP_name]['bety'])\n",
    "    sigma =  np.sqrt(emittance_phy*beta_y)\n",
    "    print(f'Jaw sigma in order to center: {(central_m-0.001)/sigma:.1f}')\n",
    "\n",
    "     \n",
    "\n",
    "    if 'ax_plot' in kwargs and kwargs['ax_plot']==True:\n",
    "        df_apertures = xcp.load_apertures(line)\n",
    "        df_apertures = change_coordinates_to_b1(df_apertures, end_s)\n",
    "        if 'coll_name' in kwargs:\n",
    "            df_coll = load_coll(kwargs['coll_name'], twiss.to_pandas(), xp.PROTON_MASS_EV, line.particle_ref.energy0)   \n",
    "        #start, stop = 6300 , 7100\n",
    "        fig, ir3_plot = plt.subplots( figsize=(13,8))\n",
    "        plot_IR3(ir3_plot, df_ref, df_chann_part, df_chann_part_upper, df_chann_part_lower, df_apertures, df_coll, end_s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "17e392e1",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_HL_IR7 = './input_files/HL_IR7_rematched/b4_sequence_patched.json'\n",
    "normalized_emittance_HL = 2.5e-6\n",
    "coll_name_HL = './input_files/CollDB_HL_tight_b4.data'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "800240b6",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Done loading line from dict.           \n",
      "Bad apertures :  {}\n",
      "Replace bad apertures with Marker\n",
      "Found suitable prebuilt kernel `default_bb3d`.\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'TCCP_name' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_6200/1813105178.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mrun_cry_tracking\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mline_name_HL_IR7\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnormalized_emittance\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnormalized_emittance_HL\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0max_plot\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcoll_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcoll_name_HL\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn_sigma\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m7.2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m/tmp/ipykernel_6200/876254833.py\u001b[0m in \u001b[0;36mrun_cry_tracking\u001b[0;34m(line_name, normalized_emittance, n_sigma, **kwargs)\u001b[0m\n\u001b[1;32m    120\u001b[0m     \u001b[0mdf_chann_part_lower\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mextract_channelled\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_chann_part_lower\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mend_s\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mTCCS_loc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mTCLA_loc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    121\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 122\u001b[0;31m     \u001b[0mupper_sig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mupper_m\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcalc_nsigma_TCCP\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_ref\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part_upper\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0memittance_phy\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    123\u001b[0m     \u001b[0mcentral_sig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcentral_m\u001b[0m \u001b[0;34m=\u001b[0m  \u001b[0mcalc_nsigma_TCCP\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_ref\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0memittance_phy\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    124\u001b[0m     \u001b[0mlower_sig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlower_m\u001b[0m \u001b[0;34m=\u001b[0m  \u001b[0mcalc_nsigma_TCCP\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_ref\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part_lower\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0memittance_phy\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/tmp/ipykernel_6200/876254833.py\u001b[0m in \u001b[0;36mcalc_nsigma_TCCP\u001b[0;34m(df_twiss, df_chann, emittance_phy)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mcalc_nsigma_TCCP\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0memittance_phy\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m     \u001b[0ms_centre\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfloat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"name\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mTCCP_name\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m's'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m     \u001b[0mhgap\u001b[0m \u001b[0;34m=\u001b[0m  \u001b[0mdf_chann\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mdf_chann\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m's'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0ms_centre\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'y'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m  \u001b[0;34m-\u001b[0m \u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m's'\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0ms_centre\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'y'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0mbeta_y\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfloat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mdf_twiss\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"name\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mTCCP_name\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m'bety'\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'TCCP_name' is not defined"
     ]
    }
   ],
   "source": [
    "run_cry_tracking(line_name = line_name_HL_IR7, normalized_emittance = normalized_emittance_HL, ax_plot = False, coll_name = coll_name_HL, n_sigma = 7.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9cfaf8be",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_HL_IR7_IR3 = './input_files/HL_IR7_IR3_rematched/b4_sequence_patched.json'\n",
    "normalized_emittance_HL = 2.5e-6\n",
    "coll_name_HL = './input_files/CollDB_HL_tight_b4.data'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "707a83ab",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "run_cry_tracking(line_name = line_name_HL_IR7_IR3, normalized_emittance = normalized_emittance_HL, ax_plot = False, coll_name = coll_name_HL,  n_sigma = 7.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e9aa49c8",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_RUN3= './input_files/flat_top_b2.json'\n",
    "normalized_emittance_RUN3 = 3.5e-6\n",
    "coll_name_RUN3 = './input_files/flat_top.yaml'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6133ab5",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "run_cry_tracking(line_name = line_name_RUN3, normalized_emittance = normalized_emittance_RUN3, ax_plot = True, coll_name = coll_name_RUN3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4318a595",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
