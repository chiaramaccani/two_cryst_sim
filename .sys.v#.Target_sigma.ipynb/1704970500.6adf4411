{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b41b6e6e",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No pytransport functionality\n",
      "No pytransport functionality\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import json\n",
    "import yaml\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "\n",
    "from matplotlib.ticker import MaxNLocator\n",
    "\n",
    "import xobjects as xo\n",
    "import xtrack as xt\n",
    "import xpart as xp\n",
    "\n",
    "import pymadx\n",
    "from xcoll_plotting import plot_functions as xcp\n",
    "import scipy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "cbdeca56",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# FUNCTION TO FIND BAD APERTURES IN LINE THAT PREVENT CLOSED ORBIT SEARCH\n",
    "\n",
    "def find_axis_intercepts(x_coords, y_coords):\n",
    "    x_intercepts = []\n",
    "    y_intercepts = []\n",
    "\n",
    "    for i in range(len(x_coords)):\n",
    "        x1, y1 = x_coords[i], y_coords[i]\n",
    "        x2, y2 = x_coords[(i + 1) % len(x_coords)], y_coords[(i + 1) % len(y_coords)]\n",
    "\n",
    "        if x1 == x2:\n",
    "        # Vertical line, no y-intercept\n",
    "            y_intercept = 0.0 if x1 == x2 == 0.0 else None\n",
    "        else:\n",
    "            slope = (y2 - y1) / (x2 - x1)\n",
    "            y_intercept = y1 - (slope * x1)\n",
    "\n",
    "        if y1 == y2:\n",
    "        # Horizontal line, no x-intercept\n",
    "            x_intercept = 0.0 if y1 == y2 == 0.0 else None\n",
    "        else:\n",
    "            slope = (x2 - x1) / (y2 - y1)\n",
    "            x_intercept = x1 - (slope * y1)\n",
    "\n",
    "        # Check if the x-intercept is within the range of x1 and x2\n",
    "        if x_intercept is not None and (x1 <= x_intercept <= x2 or x2 <= x_intercept <= x1):\n",
    "            x_intercepts.append(x_intercept)\n",
    "\n",
    "        # Check if the y-intercept is within the range of y1 and y2\n",
    "        if y_intercept is not None and (y1 <= y_intercept <= y2 or y2 <= y_intercept <= y1):\n",
    "            y_intercepts.append(y_intercept)\n",
    "\n",
    "    return x_intercepts, y_intercepts\n",
    "\n",
    "\n",
    "\n",
    "def find_bad_offset_apertures(line):\n",
    "    aperture_offsets = {}\n",
    "    for name, element in line.element_dict.items():\n",
    "        if 'offset' in name and element.__class__.__name__.startswith('XYShift'):\n",
    "            aper_name = name.split('_offset')[0]\n",
    "            aperture_offsets[aper_name] = (element.dx, element.dy)\n",
    "\n",
    "    bad_apers = {}\n",
    "    for ap_name, offset in aperture_offsets.items():\n",
    "        aperture_el = line.element_dict[ap_name]\n",
    "\n",
    "        cname= aperture_el.__class__.__name__\n",
    "        ap_dict = aperture_el.to_dict()\n",
    "\n",
    "        if cname == 'LimitEllipse':\n",
    "            x_min = -ap_dict['a']\n",
    "            x_max = ap_dict['a']\n",
    "            y_min = -ap_dict['b']\n",
    "            y_max = ap_dict['b']\n",
    "        elif cname == 'LimitRect':\n",
    "            x_min = ap_dict['min_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = ap_dict['min_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitRectEllipse':\n",
    "            x_min = -ap_dict['max_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = -ap_dict['max_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitRacetrack':\n",
    "            x_min = ap_dict['min_x']\n",
    "            x_max = ap_dict['max_x']\n",
    "            y_min = ap_dict['min_y']\n",
    "            y_max = ap_dict['max_y']\n",
    "        elif cname == 'LimitPolygon':\n",
    "            x_intercepts, y_intercepts = find_axis_intercepts(ap_dict['x_vertices'],\n",
    "                                                            ap_dict['y_vertices'])\n",
    "            x_min = min(x_intercepts)\n",
    "            x_max = max(x_intercepts)\n",
    "            y_min = min(y_intercepts)\n",
    "            y_max = max(y_intercepts)\n",
    "\n",
    "        tolerance = 5e-3\n",
    "        \"\"\"if (x_max - offset[0] < tolerance \n",
    "            or -x_min + offset[0] < tolerance \n",
    "            or y_max - offset[1] < tolerance \n",
    "            or -y_min + offset[1] < tolerance):\"\"\"\n",
    "        if (offset[0] -x_max > tolerance \n",
    "            or  -offset[0] + x_min > tolerance \n",
    "            or  offset[1] - y_max > tolerance \n",
    "            or  -offset[1] + y_min > tolerance ):\n",
    "                bad_apers[ap_name] = (x_min, x_max, y_min, y_max, offset[0], offset[1])\n",
    "\n",
    "    return bad_apers\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "1ae5953d",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# SPECIFIC CONVERSION FUNCTIONS \n",
    "\n",
    "def change_coordinates_to_b1(df, end_s):\n",
    "    if 's' in df.columns:\n",
    "        df['s'] = end_s - df['s']\n",
    "    else:\n",
    "        new_index = [end_s - i for i in df.index.values]\n",
    "        df.index = new_index \n",
    "    return df\n",
    "\n",
    "\n",
    "def reset_coord_cry_tracking(df, twiss, end_s, TCCS_loc, TCCS_name):\n",
    "    df['s'] = np.where(df['s'] <=  end_s-TCCS_loc, end_s-TCCS_loc-df['s'], 2*end_s-TCCS_loc-df['s'])\n",
    "    names = twiss.to_pandas().name.to_numpy()\n",
    "    idx = np.where(names == TCCS_name)[0][0]\n",
    "    names = np.roll(names, -idx)\n",
    "    df['name'] = names\n",
    "    df = df.sort_values(by=\"s\")\n",
    "    return df\n",
    "\n",
    "\n",
    "def extract_channelled(df, end_s, TCCS_loc, TCLA_loc):\n",
    "    df = df.loc[(df['s']<end_s-TCCS_loc) & (df['s']>end_s-TCLA_loc)]\n",
    "    return df\n",
    "\n",
    "\n",
    "def filter_aperture_rotations(df, line):    \n",
    "    aperture_offsets = []\n",
    "    for name, element in line.element_dict.items():\n",
    "        if '_tilt_entry' in name and element.__class__.__name__.startswith('SRotation'):\n",
    "            aper_name = name.split('_tilt')[0]\n",
    "            aperture_offsets.append(aper_name)#[aper_name] = (element.s)\n",
    "\n",
    "    return df[~df['name'].str.contains('|'.join(aperture_offsets), case=False)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "89e4a135",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# STANDARD CONVERSION FUNCTIONS\n",
    "\n",
    "def _norm_to_geom_emittance(norm_emittance, E0, E):\n",
    "    betagamma = _calc_betagamma(E0, E)\n",
    "    return norm_emittance / betagamma\n",
    "\n",
    "def _calc_betagamma(E0, E):\n",
    "    gamma = float(E)/E0\n",
    "    beta = np.sqrt(1.-(1./gamma)**2)\n",
    "    return beta*gamma\n",
    "\n",
    "def rad_to_deg(n):\n",
    "    return n*180/np.pi\n",
    "\n",
    "def convert_m_to_mm(val):\n",
    "    return val / 1e-3\n",
    "\n",
    "def convert_mm_to_m(val):\n",
    "    return val * 1e-3\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "1f9baf90",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# LOAD COLLIMATORS FUNCTIONS\n",
    "\n",
    "def add_collimator_halfgap(coll_df, nemitt_x, nemitt_y, \n",
    "                           reference_mass, reference_energy):\n",
    "        \n",
    "    # Calculate the geometric emittances first\n",
    "    emit_geom_x = _norm_to_geom_emittance(nemitt_x, reference_mass, reference_energy)\n",
    "    emit_geom_y = _norm_to_geom_emittance(nemitt_y, reference_mass, reference_energy)\n",
    "\n",
    "    openings = []\n",
    "    sigmas_x = []\n",
    "    sigmas_y = []\n",
    "    for name, parameters in coll_df.iterrows():\n",
    "        betx = parameters[\"betx\"]\n",
    "        bety = parameters[\"bety\"]\n",
    "        if 'gap' in parameters.index:\n",
    "            nsigma = parameters[\"gap\"]\n",
    "        elif 'nsigma' in parameters.index:\n",
    "            nsigma = parameters[\"nsigma\"]\n",
    "        angle  = parameters[\"angle\"]\n",
    "\n",
    "        sigma_x = np.sqrt(betx * emit_geom_x)\n",
    "        sigma_y = np.sqrt(bety * emit_geom_y)\n",
    "\n",
    "        a = nsigma * sigma_x\n",
    "        b = nsigma * sigma_y\n",
    "\n",
    "        x = a * np.cos(angle)\n",
    "        y = b * np.sin(angle)\n",
    "\n",
    "        sigmas_x.append(sigma_x)\n",
    "        sigmas_y.append(sigma_y)\n",
    "        openings.append(np.sqrt(x**2 + y**2))\n",
    "\n",
    "    coll_df['sigma_x'] = sigmas_x\n",
    "    coll_df['sigma_y'] = sigmas_y\n",
    "    coll_df['opening'] = openings\n",
    "    \n",
    "\n",
    "\n",
    "def load_coll(filename, optics_df, reference_mass, reference_energy,\n",
    "                          nemitt_x = 3.5e-6, nemitt_y = 3.5e-6, beam = 2):\n",
    "    \n",
    "    if filename.endswith('.yaml'):\n",
    "        # load collimators form yaml file as pandas\n",
    "        with open(filename, 'r') as file:\n",
    "            collimators = yaml.safe_load(file)   \n",
    "        coll_dict  = collimators['collimators'][f'b{beam}']\n",
    "        df = pd.DataFrame.from_dict(coll_dict, orient=\"index\")\n",
    "    else:\n",
    "        df  = xcp.load_colldb_new(filename)\n",
    "    df = df.rename_axis('name').reset_index()\n",
    "    coll_list = df['name'].to_list()\n",
    "    \n",
    "    # merge it with dataframe from twiss\n",
    "    df_col_twiss = optics_df[optics_df['name'].isin(coll_list)]\n",
    "    df_coll_tot = pd.merge(df, df_col_twiss, on=\"name\")\n",
    "    \n",
    "    add_collimator_halfgap(df_coll_tot, nemitt_x, nemitt_y, \n",
    "                           reference_mass, reference_energy)\n",
    "    return df_coll_tot\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "30b641ea",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# PLOT COLLIMATORS \n",
    "\n",
    "def plot_collimators(coll_data, ax, plane, df_twiss, end_s, df_chann, plot_offplane_coll = True):\n",
    "\n",
    "    coll_data = change_coordinates_to_b1(coll_data, end_s)\n",
    "\n",
    "\n",
    "    hors = (coll_data['angle'] <  rad_to_deg(0.1)) | (coll_data['angle'] >  rad_to_deg(6.1))\n",
    "    vers = (coll_data['angle'] >  rad_to_deg(1.5)) & (coll_data['angle'] <  rad_to_deg(1.6))\n",
    "\n",
    "\n",
    "    collimators_hor = coll_data.loc[hors]\n",
    "    collimators_ver = coll_data.loc[vers]\n",
    "    collimators_ske = coll_data.loc[(~hors) & (~vers)]\n",
    "    \n",
    "\n",
    "\n",
    "    if plane == 'h':\n",
    "        in_plane_collimators = collimators_hor\n",
    "        off_plane_collimators = pd.concat([collimators_ver, collimators_ske])\n",
    "    elif plane == 'v':\n",
    "        in_plane_collimators = collimators_ver\n",
    "        off_plane_collimators = pd.concat([collimators_hor, collimators_ske])\n",
    "    else:\n",
    "        raise Exception(f'Cannot use plane \"{[plane]}\", '\n",
    "                        'allowed planes for aperture plot are h and v')\n",
    "\n",
    "    coll_lw = 1\n",
    "\n",
    "    for index, coll in in_plane_collimators.iterrows():\n",
    "        s_centre = coll[\"s\"]\n",
    "        hgap    = coll[\"opening\"]\n",
    "\n",
    "        if(coll['name'] == TCCS_name):\n",
    "            s_centre = float(df_twiss[df_twiss[\"name\"] == TCCS_name]['s'])\n",
    "            hgap = df_twiss[df_twiss['s'] == s_centre]['n_sigma_y'].iloc[0]\n",
    "        elif(coll['name'] == TCCP_name):\n",
    "            s_centre = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['s'])\n",
    "            hgap = df_chann[df_chann['s'] == s_centre]['y'].iloc[0]\n",
    "        elif(coll['name'] == TARGET_name):\n",
    "            continue\n",
    "\n",
    "\n",
    "        orbit = coll['x'] if plane=='h' else coll['y']\n",
    "        sstart  = s_centre - coll[\"length\"]/2\n",
    "        send    = s_centre + coll[\"length\"]/2\n",
    "        w       = send-sstart\n",
    "        top_lim = plt.ylim()[1]*2\n",
    "        bot_lim = plt.ylim()[0]*2\n",
    "        h       = top_lim - hgap\n",
    "        \n",
    "        \n",
    "        if coll['side'] == 'left':\n",
    "            color = 'r' if not pd.isna(coll['crystal']) else 'k'\n",
    "            jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                        fc=color, ec=color, lw=coll_lw, zorder=10)\n",
    "            ax.add_patch(jaw)\n",
    "\n",
    "        elif coll['side'] == 'right': \n",
    "            color = 'r' if not pd.isna(coll['crystal']) else 'k'      \n",
    "            jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0, \n",
    "                                        fc=color, ec=color, lw=coll_lw,  zorder=10)\n",
    "            ax.add_patch(jaw)\n",
    "            \n",
    "        else:\n",
    "            upper_jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                          fc=\"k\", ec=\"k\", lw=coll_lw, zorder=10)\n",
    "            lower_jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0, \n",
    "                                          fc=\"k\", ec=\"k\", lw=coll_lw,  zorder=10)\n",
    "            ax.add_patch(upper_jaw)\n",
    "            ax.add_patch(lower_jaw)\n",
    "\n",
    "\n",
    "    if plot_offplane_coll:\n",
    "        for index, coll in off_plane_collimators.iterrows():\n",
    "            s_centre = coll[\"s\"]\n",
    "            sstart  = s_centre - coll[\"length\"]/2\n",
    "            send    = s_centre + coll[\"length\"]/2\n",
    "            orbit = coll['x'] if plane=='h' else coll['y']\n",
    "\n",
    "            alpha = 1\n",
    "            color = 'slategray'\n",
    "            edcgecolor = 'slategray'\n",
    "\n",
    "            coll_angle = coll['angle']\n",
    "            coll_opening = coll['opening']\n",
    "            if plane == 'h':\n",
    "                hgap = (coll_opening / np.abs(np.cos(coll_angle)) \n",
    "                        if not np.isclose(np.cos(coll_angle), 0) else np.inf)\n",
    "            elif plane == 'v':\n",
    "                hgap = (coll_opening/ np.abs(np.sin(coll_angle)) \n",
    "                        if not np.isclose(np.sin(coll_angle), 0) else np.inf)\n",
    "\n",
    "            if np.isnan(hgap) or hgap > 0.900:\n",
    "                hgap = 0 # Closed bars for non-cut collimators\n",
    "                alpha = 1\n",
    "                color = 'lightgray'\n",
    "                edcgecolor = 'lightgray'\n",
    "\n",
    "            w       = send-sstart\n",
    "            top_lim = plt.ylim()[1]*2\n",
    "            bot_lim = plt.ylim()[0]*2\n",
    "            h       = top_lim - hgap\n",
    "            upper_jaw = matplotlib.patches.Rectangle((sstart, hgap), w, h, angle=0.0, \n",
    "                                            fc=color, ec=edcgecolor, alpha=alpha, \n",
    "                                            lw=coll_lw, zorder=0)\n",
    "            \n",
    "            lower_jaw = matplotlib.patches.Rectangle((sstart, bot_lim), w, h, angle=0.0,\n",
    "                                            fc=color, ec=edcgecolor, alpha=alpha, \n",
    "                                            lw=coll_lw, zorder=0)\n",
    "\n",
    "            ax.add_patch(upper_jaw)\n",
    "            ax.add_patch(lower_jaw)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "b2685127",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "# PLOT \n",
    "\n",
    "def plot_IR3(plot_axis, df_ref, df_chann, df_chann_upper, df_chann_lower, df_apertures, end_s, df_coll=None, s_start=6300, s_stop=7100):\n",
    "    \n",
    "    plot_axis.plot(df_ref[\"s\"],df_ref[\"y\"],color=\"orange\")\n",
    "\n",
    "\n",
    "    plot_axis.plot(df_ref[\"s\"],df_ref[\"n_sigma_y\"], color='C1')\n",
    "    plot_axis.plot(df_ref[\"s\"],-df_ref[\"n_sigma_y\"], color='C1')\n",
    "    plot_axis.fill_between(df_ref[\"s\"], df_ref[\"n_sigma_y\"], -df_ref[\"n_sigma_y\"], color='C1', alpha=0.3)\n",
    "\n",
    "\n",
    "    plot_axis.plot(df_chann[\"s\"],df_chann[\"y\"], color='darkblue')\n",
    "    plot_axis.plot(df_chann_upper[\"s\"],df_chann_upper[\"y\"], color='blue')\n",
    "    plot_axis.plot(df_chann_lower[\"s\"],df_chann_lower[\"y\"], color='blue')\n",
    "    plot_axis.fill_between(df_chann[\"s\"], df_chann_upper[\"y\"],df_chann_lower[\"y\"], color='blue', alpha=0.3)\n",
    "\n",
    "\n",
    "    plot_axis.set_xlabel('s [m]',  fontsize=17)\n",
    "    plot_axis.set_xlim(s_start, s_stop)\n",
    "    plot_axis.set_ylim(-0.03, 0.03)\n",
    "    plot_axis.set_ylabel('y [m]',  fontsize=17)\n",
    "    plot_axis.grid(linestyle=':')\n",
    "    #plot_axis.set_yticks(ticks=plt.yticks()[0], labels=[f\"{x*1e3:.{0}f}\" for x in plt.yticks()[0]])\n",
    "    \n",
    "    \n",
    "    plot_axis.tick_params(axis='both', which='major', labelsize=15)\n",
    "    \n",
    "    plot_axis.text(end_s - TCCS_loc, max(plot_axis.get_yticks())+0.0008, \"TCCS\", horizontalalignment='center', fontsize=17)\n",
    "    plot_axis.text(end_s - TCCP_loc, max(plot_axis.get_yticks())+0.0008, \"TCCP\", horizontalalignment='center', fontsize=17)\n",
    "    plot_axis.text(end_s - TCLA_loc, max(plot_axis.get_yticks())+0.0008, \"TCLA\", horizontalalignment='center', fontsize=17)\n",
    "\n",
    "    # convert, xcp function handles dataframe in m\n",
    "    xcp.plot_apertures(df_apertures[['xmin', 'xmax', 'ymin', 'ymax']].apply(lambda x: convert_mm_to_m(x)), plot_axis, \"v\")\n",
    "    \n",
    "    if df_coll is not None:\n",
    "        plot_collimators(df_coll, plot_axis, \"v\", df_ref, df_chann, end_s, plot_offplane_coll = True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de00d0a3",
   "metadata": {},
   "source": [
    "# Load and Set-up"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "4865a7ba",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "## Choose a context\n",
    "context = xo.ContextCpu()         # For CPU"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "57e88f54",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "def calc_nsigma_TCCP(df_twiss, df_chann, emittance_phy, TCCP_name):\n",
    "\n",
    "    s_centre = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['s'])\n",
    "    hgap =  df_chann[df_chann['s'] == s_centre]['y'].iloc[0]  - df_twiss[df_twiss['s'] == s_centre]['y'].iloc[0]\n",
    "    beta_y = float(df_twiss[df_twiss[\"name\"] == TCCP_name]['bety'])\n",
    "    sigma =  np.sqrt(emittance_phy*beta_y)\n",
    "\n",
    "    #five_sig_gap  = df_twiss[df_twiss['s'] == s_centre]['n_sigma_y'].iloc[0] - df_twiss[df_twiss['s'] == s_centre]['y'].iloc[0]\n",
    "    #print('check: ', five_sig_gap/sigma)\n",
    "    \n",
    "    return hgap/sigma, hgap \n",
    "\n",
    "\n",
    "def run_cry_tracking(line_name, normalized_emittance, n_sigma, **kwargs):    \n",
    "\n",
    "    # load line\n",
    "    line = xt.Line.from_json(line_name)\n",
    "    end_s = line.get_length()\n",
    "\n",
    "    # insert twocryst setup\n",
    "    TCCS_name = 'tccs.5r3.b2'\n",
    "    TCCP_name = 'tccp.4l3.b2'\n",
    "    TARGET_name = 'target.4l3.b2'\n",
    "    TCLA_name = 'tcla.a5l3.b2'\n",
    "\n",
    "    TCCS_loc = end_s - 6773.7 #6775\n",
    "    TCCP_loc = end_s - 6653.3 #6655\n",
    "    TARGET_loc = end_s - (6653.3 + 0.07/2 +0.005/2)\n",
    "    TCLA_loc = line.get_s_position(TCLA_name)\n",
    "\n",
    "    line.insert_element(at_s=TCCS_loc, element=xt.Marker(), name = TCCS_name)\n",
    "    line.insert_element(at_s=TCCS_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TCCS_name + '_aper')\n",
    "    line.insert_element(at_s=TCCP_loc, element=xt.Marker(), name=TCCP_name)\n",
    "    line.insert_element(at_s=TCCP_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TCCP_name + '_aper')\n",
    "    line.insert_element(at_s=TARGET_loc, element=xt.Marker(), name=TARGET_name)\n",
    "    line.insert_element(at_s=TARGET_loc, element=xt.LimitEllipse(a_squ=0.0016, b_squ=0.0016, a_b_squ=2.56e-06), name = TARGET_name + '_aper')\n",
    "\n",
    "    bad_aper = find_bad_offset_apertures(line)\n",
    "    print('Bad apertures : ', bad_aper)\n",
    "    print('Replace bad apertures with Marker')\n",
    "    for name in bad_aper.keys():\n",
    "        line.element_dict[name] = xt.Marker()\n",
    "        print(name, line.get_s_position(name), line.element_dict[name])\n",
    "\n",
    "    line.build_tracker(_context=context)\n",
    "\n",
    "    # compute critical angle\n",
    "    beta_rel = line.particle_ref._xobject.beta0[0]\n",
    "    gamma = line.particle_ref._xobject.gamma0[0]\n",
    "    energy = line.particle_ref._xobject.p0c[0]\n",
    "\n",
    "    bend = 80.00\n",
    "\n",
    "    emittance_phy = normalized_emittance/(beta_rel*gamma)\n",
    "    pot_well_Si = 21\n",
    "    energy_well_Si = 5.7e9 / 1e-2 #eV/m\n",
    "    Rcrit = energy/energy_well_Si\n",
    "    xp_crit0 = np.sqrt(2*pot_well_Si/(energy*beta_rel))\n",
    "    critical_angle = xp_crit0*(1-Rcrit/bend)\n",
    "\n",
    "    #switch on cavities\n",
    "    speed = beta_rel*scipy.constants.c\n",
    "    harmonic_number = 35640\n",
    "    voltage = 12e6/len(line.get_elements_of_type(xt.Cavity)[1])\n",
    "    frequency = harmonic_number * speed /line.get_length()\n",
    "    for side in ['l', 'r']:\n",
    "        for cell in ['a','b','c','d']:\n",
    "            line[f'acsca.{cell}5{side}4.b2'].voltage = voltage\n",
    "            line[f'acsca.{cell}5{side}4.b2'].frequency = frequency\n",
    "\n",
    "    # set up particles\n",
    "    twiss = line.twiss()\n",
    "    beta_y_cry1  = twiss['bety', TCCS_name]\n",
    "    alpha_y_cry1 = twiss['alfy', TCCS_name]\n",
    "\n",
    "    cry_part_chann = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6,\n",
    "                            _context=context)\n",
    "\n",
    "\n",
    "    cry_part_chann_upper = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6+critical_angle,\n",
    "                            _context=context)\n",
    "\n",
    "\n",
    "    cry_part_chann_lower = xp.Particles(p0c=energy, #eV\n",
    "                            q0=1, mass0=xp.PROTON_MASS_EV,\n",
    "                            x=0,\n",
    "                            px=0,\n",
    "                            y=n_sigma*np.sqrt(emittance_phy*beta_y_cry1),\n",
    "                            py=-n_sigma*alpha_y_cry1*np.sqrt(emittance_phy/beta_y_cry1)+50e-6-critical_angle,\n",
    "                            _context=context)\n",
    "\n",
    "    # track particles\n",
    "    df_ref = change_coordinates_to_b1(twiss.to_pandas(), end_s)\n",
    "    df_ref = filter_aperture_rotations(df_ref, line)\n",
    "    df_ref['n_sigma_y'] = n_sigma*np.sqrt(emittance_phy*df_ref['bety'])\n",
    "\n",
    "    line.track(cry_part_chann, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part = filter_aperture_rotations(df_chann_part, line)\n",
    "    df_chann_part = extract_channelled(df_chann_part,end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    line.track(cry_part_chann_upper, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part_upper = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part_upper = filter_aperture_rotations(df_chann_part_upper, line)\n",
    "    df_chann_part_upper = extract_channelled(df_chann_part_upper, end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    line.track(cry_part_chann_lower, turn_by_turn_monitor = 'ONE_TURN_EBE', ele_start=TCCS_name)\n",
    "    df_chann_part_lower = reset_coord_cry_tracking(pd.DataFrame(list(zip(line.record_last_track.s[0], -1*line.record_last_track.x[0], line.record_last_track.y[0])), columns =['s', 'x', 'y']), twiss, end_s, TCCS_loc, TCCS_name)\n",
    "    df_chann_part_lower = filter_aperture_rotations(df_chann_part_lower, line)\n",
    "    df_chann_part_lower = extract_channelled(df_chann_part_lower, end_s, TCCS_loc, TCLA_loc)\n",
    "\n",
    "    upper_sig, upper_m = calc_nsigma_TCCP(df_ref, df_chann_part_upper, emittance_phy, TCCP_name)\n",
    "    central_sig, central_m =  calc_nsigma_TCCP(df_ref, df_chann_part, emittance_phy, TCCP_name)\n",
    "    lower_sig, lower_m =  calc_nsigma_TCCP(df_ref, df_chann_part_lower, emittance_phy, TCCP_name)\n",
    "\n",
    "    print(f'\\nEnergy: {energy/1e9:.2f} GeV \\t TCCS sigma setting: {n_sigma}' )\n",
    "    print(f'\\nUpper: {upper_sig:.2f} sigma, {upper_m*1e3:.2f} mm')\n",
    "    print(f'Central: {central_sig:.2f} sigma, {central_m*1e3:.2f} mm')\n",
    "    print(f'Lower: {lower_sig:.2f} sigma, {lower_m*1e3:.2f} mm')\n",
    "    print(f'\\nDimesion of the 5 sigma channelled spot (upper-lower): {(upper_m-lower_m)*1e3:.2f} mm   \\tCrystal height: 2 mm')\n",
    "    print(f'Center the spot in the crystal: [{central_m*1e3-1:.2f},{central_m*1e3+1:.2f}] mm')\n",
    "    beta_y = float(df_ref[df_ref[\"name\"] == TCCP_name]['bety'])\n",
    "    sigma =  np.sqrt(emittance_phy*beta_y)\n",
    "    print(f'Jaw sigma in order to center: {(central_m-0.001)/sigma:.1f}')\n",
    "\n",
    "     \n",
    "\n",
    "    if 'ax_plot' in kwargs and kwargs['ax_plot']==True:\n",
    "        df_apertures = xcp.load_apertures(line)\n",
    "        df_apertures = change_coordinates_to_b1(df_apertures, end_s)\n",
    "        if 'coll_name' in kwargs:\n",
    "            df_coll = load_coll(kwargs['coll_name'], twiss.to_pandas(), xp.PROTON_MASS_EV, line.particle_ref.energy0)   \n",
    "        #start, stop = 6300 , 7100\n",
    "        fig, ir3_plot = plt.subplots( figsize=(13,8))\n",
    "        plot_IR3(ir3_plot, df_ref, df_chann_part, df_chann_part_upper, df_chann_part_lower, df_apertures, df_coll, end_s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "17e392e1",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_HL_IR7 = './input_files/HL_IR7_rematched/b4_sequence_patched.json'\n",
    "normalized_emittance_HL = 2.5e-6\n",
    "coll_name_HL = './input_files/CollDB_HL_tight_b4.data'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "800240b6",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Done loading line from dict.           \n",
      "Bad apertures :  {}\n",
      "Replace bad apertures with Marker\n",
      "Found suitable prebuilt kernel `default_bb3d`.\n",
      "\n",
      "Energy: 7000.00 GeV \t TCCS sigma setting: 7.2\n",
      "\n",
      "Upper: 38.21 sigma, 11.74 mm\n",
      "Central: 36.87 sigma, 11.33 mm\n",
      "Lower: 35.53 sigma, 10.92 mm\n",
      "\n",
      "Dimesion of the 5 sigma channelled spot (upper-lower): 0.82 mm   \tCrystal height: 2 mm\n",
      "Center the spot in the crystal: [10.33,12.33] mm\n",
      "Jaw sigma in order to center: 33.6\n"
     ]
    }
   ],
   "source": [
    "run_cry_tracking(line_name = line_name_HL_IR7, normalized_emittance = normalized_emittance_HL, ax_plot = False, coll_name = coll_name_HL, n_sigma = 7.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "9cfaf8be",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_HL_IR7_IR3 = './input_files/HL_IR7_IR3_rematched/b4_sequence_patched.json'\n",
    "normalized_emittance_HL = 2.5e-6\n",
    "coll_name_HL = './input_files/CollDB_HL_tight_b4.data'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "707a83ab",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Done loading line from dict.           \n",
      "Bad apertures :  {}\n",
      "Replace bad apertures with Marker\n",
      "Found suitable prebuilt kernel `default_bb3d`.\n",
      "\n",
      "Energy: 7000.00 GeV \t TCCS sigma setting: 7.2\n",
      "\n",
      "Upper: 50.26 sigma, 11.34 mm\n",
      "Central: 48.44 sigma, 10.93 mm\n",
      "Lower: 46.62 sigma, 10.52 mm\n",
      "\n",
      "Dimesion of the 5 sigma channelled spot (upper-lower): 0.82 mm   \tCrystal height: 2 mm\n",
      "Center the spot in the crystal: [9.93,11.93] mm\n",
      "Jaw sigma in order to center: 44.0\n"
     ]
    }
   ],
   "source": [
    "run_cry_tracking(line_name = line_name_HL_IR7_IR3, normalized_emittance = normalized_emittance_HL, ax_plot = False, coll_name = coll_name_HL,  n_sigma = 7.2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "e9aa49c8",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": [
    "line_name_RUN3= './input_files/flat_top_b2.json'\n",
    "normalized_emittance_RUN3 = 3.5e-6\n",
    "coll_name_RUN3 = './input_files/flat_top.yaml'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "e6133ab5",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Done loading line from dict.           \n",
      "Bad apertures :  {'tctph.4r8.a.b2_aper': (-0.04, 0.04, -0.04, 0.04, 0.16672558295218318, -0.0), 'vmabc.4l2.b.b2_aper': (-0.0315, 0.0315, -0.0315, 0.0315, -0.18383135991897473, -0.0)}\n",
      "Replace bad apertures with Marker\n",
      "tctph.4r8.a.b2_aper 3461.1485832278486 Marker(_dummy=0)\n",
      "vmabc.4l2.b.b2_aper 23206.82195866583 Marker(_dummy=0)\n",
      "Found suitable prebuilt kernel `default_bb3d`.\n",
      "\n",
      "Energy: 6800.00 GeV \t TCCS sigma setting: 5\n",
      "\n",
      "Upper: 31.18 sigma, 11.53 mm\n",
      "Central: 30.05 sigma, 11.11 mm\n",
      "Lower: 28.91 sigma, 10.69 mm\n",
      "\n",
      "Dimesion of the 5 sigma channelled spot (upper-lower): 0.84 mm   \tCrystal height: 2 mm\n",
      "Center the spot in the crystal: [10.11,12.11] mm\n",
      "Jaw sigma in order to center: 27.3\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'TCCS_loc' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_6200/3360797850.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mrun_cry_tracking\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mline_name_RUN3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnormalized_emittance\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnormalized_emittance_RUN3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0max_plot\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcoll_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcoll_name_RUN3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn_sigma\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m/tmp/ipykernel_6200/1229344549.py\u001b[0m in \u001b[0;36mrun_cry_tracking\u001b[0;34m(line_name, normalized_emittance, n_sigma, **kwargs)\u001b[0m\n\u001b[1;32m    143\u001b[0m         \u001b[0;31m#start, stop = 6300 , 7100\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    144\u001b[0m         \u001b[0mfig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mir3_plot\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msubplots\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mfigsize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m13\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m8\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 145\u001b[0;31m         \u001b[0mplot_IR3\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mir3_plot\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_ref\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part_upper\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_chann_part_lower\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_apertures\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf_coll\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mend_s\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m/tmp/ipykernel_6200/659289637.py\u001b[0m in \u001b[0;36mplot_IR3\u001b[0;34m(plot_axis, df_ref, df_chann, df_chann_upper, df_chann_lower, df_apertures, end_s, df_coll, s_start, s_stop)\u001b[0m\n\u001b[1;32m     27\u001b[0m     \u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtick_params\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'both'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mwhich\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'major'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlabelsize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m15\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 29\u001b[0;31m     \u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend_s\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mTCCS_loc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmax\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_yticks\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;36m0.0008\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"TCCS\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhorizontalalignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'center'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfontsize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m17\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     30\u001b[0m     \u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend_s\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mTCCP_loc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmax\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_yticks\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;36m0.0008\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"TCCP\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhorizontalalignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'center'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfontsize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m17\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     31\u001b[0m     \u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend_s\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mTCLA_loc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmax\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mplot_axis\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_yticks\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;36m0.0008\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"TCLA\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhorizontalalignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'center'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfontsize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m17\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'TCCS_loc' is not defined"
     ]
    },
    {
     "data": {
      "image/png": "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pZfCTTctp7NzNe9//y387W8bueaaF3Ljja9l586pvP/9YbjaC14Av/99OFdoIhpAEIbDPfZYOF/os5+Fc899Pueddzzf+tYDXHjhOhYuDL1VxXy8R9u1DeVsR1nbUdbJop6gAtF1guz09PRQWVkZdxmJp5wLL5uFm2+Gj38cpk8PFz5taOjhllvu54EHnuT44+dy/fUvZc6cmdx6K/zyl1BfH57/D/8Qpru2sH17mHBh50648cY+vvnN23jmmRY++tGr+a//mktFRZgx7sgjbeopJG3XNpSzHWVtR1nbUE9Qkent7Y27hNRobm6Ou4RUUM6FtXVr6PW54QY44wz4p3+CI47YyIc+9F0efPBJXve68/nc5/6efftmct118ItfhOmuH3oIPvhBuwYQhOmwf/97mDoV/vVfy7nmmldTXz+FL33pZ/zjP+6lrQ1e8pIw7Xax0XZtQznbUdZ2lHWyqBFUILqCsJ25umCJCeVcOHfeCaefHhoWV18N731vhocffoh/+qfbKCkp4f/9v1dy5ZUX8MMflvLhD4eLmn72s/DrX8Npp8VT88KF8MAD4D38+7/X8IEPvIZMpp9bbvkp73pXD8uXw1VXhceLibZrG8rZjrK2o6yTRY2gAunv74+7hNRoa2uLu4RUUM7j190dJj94+cvDdXs+/GE477yd3HTTrfz853/lxS8+nS996U2Ulk7lAx8IM7BdcEFofHz0o1BTE2/9p54aGmLt7fC//zuDD33oVWzfvoff/e4XvO51/dx+e5iooZhou7ahnO0oazvKOlnUCCqQkhJFaaVqos4KlwMo5/FZsSKcV/PlL8PFF8NHPuLZvLmRD33oB+zevY9PfvJVXHPNi/nZzyr48Ifn0t4On/kM3H03nHnm5LkezwUXhBnhNm6En/50Pu9976U88cQmtm37Dc95jueznw3TbBcLbdc2lLMdZW1HWSeLxnCJiBSQ9/DVr8L114fzeN79bjj99Ha+8pW7Wb58I+eddzzvfe+LaWmp4frrw4VSL7igmy99qZqzzpo8jZ98l18O//u/8K53wdSpJ/P61+/h1lv/wGteU8dxxz2Xt741TPN97rlxVyoiIjI6agQVSDabjbuE1OguxrOxi5ByHruWFnjHO8KU1qefDq9/vWfr1if50Ifux3vP+973Ei666DT+7/8cP/0pTJkCn/oUvP71Oznh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\n",
      "text/plain": [
       "<Figure size 936x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "run_cry_tracking(line_name = line_name_RUN3, normalized_emittance = normalized_emittance_RUN3, ax_plot = True, coll_name = coll_name_RUN3, n_sigma=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4318a595",
   "metadata": {
    "vscode": {
     "languageId": "python"
    }
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
